#!/usr/bin/env bash
#shellcheck disable=SC2034,SC1091,SC2155
# symlink v1.3.8 - Creates symlinks in /usr/local/bin for executable files
#
# Creates symbolic links in /usr/local/bin for executable files, making them
# accessible system-wide. Features include:
#   - .symlink configuration files for batch processing
#   - Auto-sudo for elevated privileges
#   - Interactive/non-interactive mode detection
#   - Safety features for critical system files
#   - Debug mode with detailed logging
#   - Dry-run mode to preview changes
#   - Broken symlink detection and cleanup
#   - Ownership and permissions preservation
# License: GPL-3.0
set -euo pipefail
shopt -s inherit_errexit shift_verbose extglob nullglob
# Enforce root privileges at the very beginning
((EUID)) && {
  sudo -ln &>/dev/null || { >&2 echo "$(basename "$0"): Requires root, or non-interactive sudo privileges."; exit 1; }
  sudo -E "$0" "$@"
  exit $?
}

declare -- VERSION SCRIPT_PATH SCRIPT_NAME SCRIPT_DIR ORIG_DIR DEFAULT_TARGET_DIR CRITICAL_FILES
VERSION='1.4.0'
SCRIPT_PATH=$(realpath -- "$0")
SCRIPT_NAME=${SCRIPT_PATH##*/}
SCRIPT_DIR=${SCRIPT_PATH%/*}
ORIG_DIR=$(pwd)
DEFAULT_TARGET_DIR='/usr/local/bin'
CRITICAL_FILES=(awk bash cat chgrp chmod chown clang cp dash date df du echo file find gcc git grep groupadd groupdel head hostname ifconfig ip kill less login ls make mkdir mount mv netstat passwd ping ps reboot rm rmdir sed sh shutdown ss sudo tail top touch umount useradd userdel vi vim zsh)
# Initialize key variables early
declare -i DRY_RUN=0 VERBOSE=0 DEBUG=0 PROMPT=0
# Set PROMPT based on whether we're running interactively
# If stdin is not a terminal, disable prompting by default
# PROMPT=0  Non-interactive - no prompting by default
[[ -t 0 ]] && PROMPT=1 || :  # Interactive - prompting enabled by default

declare -i SCANSYMLINK=0
declare -i DELETE_DEAD_SYMLINKS=0
declare -i LISTIT=0
declare -i FIND_MAX_DEPTH=5
declare -a CREATED_LINKS=()
declare -a REPLACED_LINKS=()
declare -a SKIPPED_LINKS=()
declare -a ERROR_LINKS=()

# --------------------------------------------------------------------------------
# Message functions and color support
# --------------------------------------------------------------------------------
if [[ -t 2 ]]; then
  declare -- RED=$'\033[0;31m' GREEN=$'\033[0;32m' YELLOW=$'\033[0;33m' CYAN=$'\033[0;36m' NC=$'\033[0m'
else
  declare -- RED='' GREEN='' YELLOW='' CYAN='' NC=''
fi

# Core message function using FUNCNAME for context
_msg() {
  local -- status="${FUNCNAME[1]}" prefix="$SCRIPT_NAME:" msg
  case "$status" in
    success) prefix+=" ${GREEN}✓${NC}" ;;
    warn)    prefix+=" ${YELLOW}⚡${NC}" ;;
    info)    prefix+=" ${CYAN}◉${NC}" ;;
    error)   prefix+=" ${RED}✗${NC}" ;;
    debug)   prefix+=" ${RED}DEBUG${NC}:" ;;
    *)       ;;
  esac
  for msg in "$@"; do printf '%s %s\n' "$prefix" "$msg"; done
}

# Conditional output based on verbosity
vecho() { ((VERBOSE)) || return 0; _msg "$@"; }
success() { ((VERBOSE)) || return 0; >&2 _msg "$@"; }
warn() { ((VERBOSE)) || return 0; >&2 _msg "$@"; }
info() { ((VERBOSE)) || return 0; >&2 _msg "$@"; }
debug() { ((DEBUG)) || return 0; >&2 _msg "$@"; }
# Unconditional output
error() { >&2 _msg "$@"; }
die() { (($# > 1)) && error "${@:2}"; exit "${1:-0}"; }
# yes/no prompt
yn() {
  ((PROMPT)) || return 0
  local -- reply
  >&2 read -r -n 1 -p "$(warn "$1 (y/n) ")" reply
#  >&2 read -r -n 1 -p "$SCRIPT_NAME: ${YELLOW}$1${NC} (y/n) " reply
  >&2 echo
  [[ ${reply,,} == y ]]
}

# --------------------------------------------------------------------------------
# Utility functions
# --------------------------------------------------------------------------------
# Validate argument presence
noarg() {
  (($# > 1)) && [[ ${2:0:1} != '-' ]] || die 2 "Missing argument for option ${1@Q}"
#  if (($# < 2)) || [[ ${2:0:1} == '-' ]]; then
#    die 2 "Missing argument for option ${1@Q}"
#  fi
}

# Display declared variables for debugging
decp() { declare -p "$@" | sed 's/^declare -[a-zA-Z-]* //'; }

# Pluralization helper
s() { (( ${1:-1} == 1 )) || echo -n 's'; }


# --------------------------------------------------------------------------------
# Pre-Check DEBUG flag
# --------------------------------------------------------------------------------
# Enable debug mode if requested through environment variable or command line flag
[[ -z "${SYMLINK_DEBUG:-}" ]] || DEBUG=1
if (($#)); then
  for arg in "$@"; do [[ "$arg" == "--debug" ]] && { DEBUG=1; break; }; done
fi
# Setup debug trace if in debug mode
declare -- TRACEFILE=/dev/null
if ((DEBUG)); then
  TRACEFILE=/tmp/symlink-trace-"$(whoami)"-"$$".log
  { echo "TRACE: Script started at $(date +Is)"
    echo "TRACE: Arguments: $*"
    echo "TRACE: Working dir: $(pwd)"
    echo "TRACE: Running as: $(whoami), EUID: $EUID"
  } > "$TRACEFILE"
  debug "Debug mode enabled (logging to $TRACEFILE)"
fi
# Root privileges are now enforced at the beginning of the script
debug "Running as root user: EUID=$EUID"

# --------------------------------------------------------------------------------
# Display usage information and exit
# --------------------------------------------------------------------------------
usage() {
  local -i exit_code="${1:-0}"
  cat <<EOT
$SCRIPT_NAME $VERSION - Create symlinks in /usr/local/bin for executable files

Requires root privileges (automatically uses sudo if needed).

DESCRIPTION:
  This utility creates symbolic links in /usr/local/bin for executable files,
  making them accessible system-wide via the command line. It can process
  individual files or scan for .symlink configuration files that list
  multiple executables to be linked. The tool auto-detects interactive mode
  and adjusts prompting behavior accordingly, with special handling for
  critical system files.

COMMON USAGE PATTERNS:
  • Link a specific script:
    $SCRIPT_NAME /path/to/my-script.sh

  • Link multiple scripts:
    $SCRIPT_NAME script1.sh script2.sh /path/to/tool3

  • Scan for .symlink files and process them (admin mode):
    $SCRIPT_NAME -SPd [startpath]
    (Scans for .symlink files with no prompts and cleans broken links)

OPERATION MODES:
  1. Direct linking:
     $SCRIPT_NAME [-P] [-d] [-v|-q] [-n] scriptpath [scriptpath...]
     Links specific executable files to /usr/local/bin.

  2. Scan-based linking:
     $SCRIPT_NAME -S [-P] [-d] [-v|-q] [-n] [startpath]
     Scans for .symlink files and creates links for files listed in them.
     If startpath is omitted, the current directory is used.
     NOTE: Scanning is limited to max depth of $FIND_MAX_DEPTH for safety.

  3. List-only mode:
     $SCRIPT_NAME -l [startpath]
     Lists contents of all .symlink files without creating links.

FORMAT OF .SYMLINK FILES:
  Plain text files containing one executable per line, with optional custom symlink name.
  • Format: source_path [custom_symlink_name]
  • If custom_symlink_name is omitted, uses basename of source_path
  • Empty lines and lines starting with # are ignored
  • Each file path should be relative to the .symlink file's location
  • File paths are trimmed of leading/trailing whitespace
  • Example:
      # This is a comment
      script1                    # Creates /usr/local/bin/script1
      tools/script2              # Creates /usr/local/bin/script2
      bin/tool3                  # Creates /usr/local/bin/tool3
      spacetime.bash spacetime   # Creates /usr/local/bin/spacetime

OPTIONS:
  -t, --target-dir       Define target dir (default $DEFAULT_TARGET_DIR)
  -S, --scan-symlink     Scan for .symlink files and process them
  -d, --delete-broken-symlinks
                         Clean up broken symlinks after creating new links
  -P, --no-prompt        Do not prompt before replacing existing files
  -l, --list             List contents of all .symlink files only
  -n, --dry-run          Show what would happen without making changes
  -v, --verbose          Show detailed output
  -q, --quiet            Suppress informational messages (default in non-interactive mode)
  -V, --version          Display version information
  -h, --help             Show this help message
  -D, --debug            Enable debug mode with detailed logging

SAFETY FEATURES:
  • Critical system files (${#CRITICAL_FILES[@]} system binaries) require explicit confirmation
  • Scanning in $DEFAULT_TARGET_DIR is restricted for safety
  • Path resolution operations have timeouts to prevent hanging
  • All operations can be previewed with dry-run mode
  • Auto-detection of interactive/non-interactive mode
  • Ownership and permissions preservation for symlinks
  • Batch processing with controlled execution

EXIT CODES:
  0: Success
  1: General error
  2: Permission denied
  3: File not found
  22: Invalid option
  50: No symlink files found

ENVIRONMENT VARIABLES:
  SYMLINK_DEBUG          Set to any value to enable debug mode
  SYMLINK_FORCE_CRITICAL Set to override safety checks for critical system files

EXAMPLES:
  $SCRIPT_NAME -SPd /my/scripts
    Scans /my/scripts recursively for .symlink files and processes them without prompts.

  $SCRIPT_NAME -n ./my-script.sh
    Dry run to show what would happen when creating a symlink for my-script.sh.

  $SCRIPT_NAME -l ~/bin
    List all .symlink configurations in the ~/bin directory without creating links.

  $SCRIPT_NAME -Sd /opt/tools
    Process all .symlink files in /opt/tools without prompting for confirmation.

  $SCRIPT_NAME --debug -nSPd /path/to/scripts
    Perform a dry run with detailed debug logging to a temporary file.

EOT
  exit "$exit_code"
}

# --------------------------------------------------------------------------------
# String manipulation functions
# --------------------------------------------------------------------------------
# Remove leading/trailing whitespace from a string
trim() {
  local -- v="$*"
  v="${v#"${v%%[![:blank:]]*}"}"  # Remove leading whitespace
  echo -n "${v%"${v##*[![:blank:]]}"}"  # Remove trailing whitespace
}

# --------------------------------------------------------------------------------
# File validation functions
# --------------------------------------------------------------------------------
# Check if a file is a critical system file
is_critical_file() {
  local -- filename="$1" critical
  for critical in "${CRITICAL_FILES[@]}"; do
    [[ "$filename" == "$critical" ]] && return 0
  done
  return 1
}

# --------------------------------------------------------------------------------
# Core symlink operations
# --------------------------------------------------------------------------------
# Create a symbolic link (handles errors and critical system files)
create_symlink() {
  local -- source_path="$1" target_dir="$2" custom_target_name="${3:-}"
  local -- target_name target_path yn
  local -i exit_code=0

  # Get target filename - use custom name if provided, otherwise use basename
  target_name="${custom_target_name:-$(basename "$source_path")}"
  target_path="${target_dir}/${target_name}"
  debug "create_symlink: $source_path → $target_path"

  # Check if the source file exists and is executable
  if [[ ! -f "$source_path" ]]; then
    error "Source file does not exist: '$source_path'"
    ERROR_LINKS+=("$source_path → $target_path (source not found)")
    if ((DRY_RUN)); then
      info "[DRY RUN] Would fail: Source file not found ${source_path@Q}"
      return 0
    fi
    return 3
  fi

  if [[ ! -x "$source_path" ]]; then
    error "Source file is not executable: '$source_path'"
    ERROR_LINKS+=("$source_path → $target_path (not executable)")
    if ((DRY_RUN)); then
      info "[DRY RUN] Would fail: Source file not executable ${source_path@Q}"
      return 0
    fi
    return 1
  fi

  # Get absolute path to source with timeout to prevent hanging
  local -- source_abs_path
  source_abs_path=$(timeout 2 readlink -en -- "$source_path" 2>/dev/null || timeout 2 readlink -fn -- "$source_path")

  if [[ -z "$source_abs_path" ]]; then
    error "Failed to resolve source path: '$source_path'"
    ERROR_LINKS+=("$source_path → $target_path (path resolution failed)")
    return 1
  fi

  # Check if target directory exists and is writable
  if [[ ! -d "$target_dir" ]]; then
    error "Target directory does not exist: '$target_dir'"
    ERROR_LINKS+=("$source_path → $target_path (target dir not found)")
    if ((DRY_RUN)); then
      info "[DRY RUN] Would fail: Target directory does not exist ${target_dir@Q}"
      return 0
    fi
    return 3
  fi

  if [[ ! -w "$target_dir" ]]; then
  error "No write permission on target directory ${target_dir@Q}"
    ERROR_LINKS+=("$source_path → $target_path (permission denied)")
    if ((DRY_RUN)); then
      info "[DRY RUN] Would fail: No write permission on target directory ${target_dir@Q}"
      return 0
    fi
    return 2
  fi

  # Check for critical system files
  if is_critical_file "$target_name"; then
    warn "${target_name@Q} appears to be a critical system file!"

    # In non-interactive or dry-run mode, handle specially
    if ((DRY_RUN)); then
      info "[DRY RUN] Would prompt user for confirmation before replacing critical file"
      SKIPPED_LINKS+=("$source_path → $target_path (critical file)")
      return 0
    fi

    # Always prompt for critical files, unless explicitly overridden with environment variable
    if ((PROMPT)) || [[ -z "${SYMLINK_FORCE_CRITICAL:-}" ]]; then
      if ! yn "Are you ABSOLUTELY SURE you want to replace it?"; then
        info "Skipping ${target_name@Q} (critical system file)"
        SKIPPED_LINKS+=("$source_path → $target_path (critical file)")
        return 0
      fi
      warn "User explicitly confirmed replacing critical system file"
    else
      # In non-interactive mode with PROMPT=0, we'd normally replace without asking,
      # but for critical files we should skip by default for safety
      # unless overridden with SYMLINK_FORCE_CRITICAL
      if [[ -n "${SYMLINK_FORCE_CRITICAL:-}" ]]; then
        warn "CRITICAL FILE REPLACED: ${target_name@Q}' (non-interactive mode with SYMLINK_FORCE_CRITICAL)"
      else
        info "Skipping ${target_name@Q} (critical system file in non-interactive mode)"
        SKIPPED_LINKS+=("$source_path → $target_path (critical file in non-interactive mode)")
        return 0
      fi
    fi
  fi

  # Dry run mode
  if ((DRY_RUN)); then
    if [[ -L "$target_path" ]]; then
      # Check if it's already pointing to our target
      local -- current_target
      current_target=$(readlink -f -- "$target_path" 2>/dev/null || readlink -en -- "$target_path")
      if [[ "$current_target" == "$source_abs_path" ]]; then
        info "[DRY RUN] Would skip (already linked): '$source_abs_path' → '$target_path'"
        SKIPPED_LINKS+=("$source_path → $target_path (already exists)")
      else
        info "[DRY RUN] Would replace symlink: '$source_abs_path' → '$target_path'"
        REPLACED_LINKS+=("$source_path → $target_path (replaced symlink)")
      fi
    elif [[ -e "$target_path" ]]; then
      info "[DRY RUN] Would replace file: '$source_abs_path' → '$target_path'"
      REPLACED_LINKS+=("$source_path → $target_path (replaced file)")
    else
      info "[DRY RUN] Would create symlink: '$source_abs_path' → '$target_path'"
      CREATED_LINKS+=("$source_path → $target_path")
    fi
    return 0
  fi

  # Handle existing symlink
  if [[ -L "$target_path" ]]; then
    info "Symlink exists ${target_path@Q}"

    change_symlink_owner_perms "$source_abs_path" "$target_path"

    # Check if it's already pointing to our target
    local -- current_target
    current_target=$(readlink -f -- "$target_path" 2>/dev/null || readlink -en -- "$target_path")
    if [[ "$current_target" == "$source_abs_path" ]]; then
      info "Symlink already points to ${source_abs_path@Q}, skipping"
      SKIPPED_LINKS+=("$source_path → $target_path (already exists)")
      return 0
    fi

    if ((PROMPT)); then
      if ! yn "Remove existing symlink?"; then
        info "Skipping ${target_name@Q}"
        SKIPPED_LINKS+=("$source_path → $target_path (user skipped)")
        return 0
      fi
    else
      info "Removing existing symlink ${target_path@Q}"
    fi

    if ! rm "$target_path"; then
      error "Failed to remove existing symlink ${target_path@Q}"
      ERROR_LINKS+=("$source_path → $target_path (remove failed)")
      return 1
    fi
    REPLACED_LINKS+=("$source_path → $target_path (replaced symlink)")
  fi

  # Handle existing regular file
  if [[ -e "$target_path" ]]; then
    info "File exists ${target_path@Q}"
    if ((PROMPT)); then
      if ! yn "Remove existing file?"; then
        info "Skipping ${target_name@Q}"
        SKIPPED_LINKS+=("$source_path → $target_path (user skipped)")
        return 0
      fi
    else
      info "Removing existing file ${target_path@Q}"
    fi

    if ! rm "$target_path"; then
      error "Failed to remove existing file ${target_path@Q}"
      ERROR_LINKS+=("$source_path → $target_path (remove failed)")
      return 1
    fi
    REPLACED_LINKS+=("$source_path → $target_path (replaced file)")
  fi

  # Create the symbolic link
  info "Creating symlink: '$source_abs_path' → '$target_path'"
  if ! ln -s "$source_abs_path" "$target_path"; then
    error "Failed to create symlink ${target_path@Q}"
    ERROR_LINKS+=("$source_path → $target_path (link failed)")
    return 1
  fi

  CREATED_LINKS+=("$source_path → $target_path")
  success "Created symlink ${target_name@Q}"

  change_symlink_owner_perms "$source_abs_path" "$target_path"

  # Show details of the created symlink if verbose
  ((VERBOSE)) && { ls -lsd "$target_path" 2>/dev/null || :; }

  return 0
}

# Updates the symlink's ownership, permissions, and timestamp to match the source file
# This ensures the symlink maintains the same ownership, permissions, and timestamp as the original file
change_symlink_owner_perms() {
  local -- source_abs_path="$1" target_path="$2"
  # Get owner and group of the source file
  local -- owner group
  owner=$(stat -c '%U' "$source_abs_path")
  group=$(stat -c '%G' "$source_abs_path")
  # Get permissions of the source file
  debug "touch -h -r $source_abs_path $target_path"
  touch -h -r "$source_abs_path" "$target_path"
  # Change ownership of the symlink to match the source
  debug "chown -h $owner:$group $target_path"
  chown -h "$owner":"$group" "$target_path"
  return 0
}


# --------------------------------------------------------------------------------
# Cleanup operations
# --------------------------------------------------------------------------------
# Find and delete broken symlinks in the target directory
delete_broken_symlinks() {
  local -- target_dir="$1" link
  local -i count=0
  local -a broken_links=()

  info "Finding broken symlinks in ${target_dir@Q}"

  if ((DRY_RUN)); then
    debug "Checking for broken symlinks in dry-run mode (safe approach)"

    # Use pure bash approach for safety
    for link in "$target_dir"/*; do
      # Skip if it's not a symlink
      [[ -L "$link" ]] || continue

      # Check if it's broken - target doesn't exist
      [[ -e "$link" ]] && continue || :

      # This is a broken symlink
      info "[DRY RUN] Would delete broken symlink ${link@Q}"
      count+=1
    done

    ((count)) && info "[DRY RUN] Would delete $count broken symlinks"
    return 0
  fi

  # REAL MODE: Actually delete broken symlinks
  debug "Finding and deleting broken symlinks (safe approach)"
  # The same pure bash approach - safer than using find
  for link in "$target_dir"/*; do
    # Skip if it's not a symlink
    [[ -L "$link" ]] || continue
    # Skip if the symlink target exists (i.e., not broken)
    [[ -e "$link" ]] && continue || :
    # This is a broken symlink - delete it
    info "Deleting broken symlink ${link@Q}"
    if rm "$link"; then
      count+=1
    else
      warn "Failed to delete broken symlink ${link@Q}"
    fi
  done

  ((count)) && success "Deleted $count broken symlinks"

  debug 'delete_broken_symlinks completed successfully'
  return 0
}

# --------------------------------------------------------------------------------
# Summary and reporting
# --------------------------------------------------------------------------------
# Print a detailed summary of all operations performed
# Shows created, replaced, skipped, and error links
# Adapts output based on DRY_RUN and VERBOSE flags
print_summary() {
  # Format output differently for dry run mode
  if ((DRY_RUN)); then
    if (( ${#CREATED_LINKS[@]} == 0 && ${#REPLACED_LINKS[@]} ==0 &&
          ${#SKIPPED_LINKS[@]} ==0 && ${#ERROR_LINKS[@]} == 0 )); then
      echo "[DRY RUN] No operations would be performed."
      return 0
    fi
    echo '<DRY RUN>'
  else
    if (( ${#CREATED_LINKS[@]} == 0 && ${#REPLACED_LINKS[@]} == 0 &&
          ${#SKIPPED_LINKS[@]} == 0 && ${#ERROR_LINKS[@]} == 0 )); then
      ((VERBOSE)) && echo "[DRY RUN] No operations performed."
      return 0
    fi
  fi

  # Calculate total processed
  local -i total
  total=$(( ${#CREATED_LINKS[@]} + ${#REPLACED_LINKS[@]} + ${#SKIPPED_LINKS[@]} + ${#ERROR_LINKS[@]} ))
  echo "Symlinks processed: $total"

  (( ${#CREATED_LINKS[@]} )) && {
    echo "Symlinks created: ${#CREATED_LINKS[@]}"
    ((VERBOSE)) && {
      local -- link
      for link in "${CREATED_LINKS[@]}"; do
        echo "  $link"
      done
    }
  }

  (( ${#REPLACED_LINKS[@]} )) && {
    echo "Symlinks replaced: ${#REPLACED_LINKS[@]}"
    ((VERBOSE)) && {
      local -- link
      for link in "${REPLACED_LINKS[@]}"; do
        echo "  $link"
      done
    }
  }

  (( ${#SKIPPED_LINKS[@]} )) && {
    echo "Skipped symlinks: ${#SKIPPED_LINKS[@]}"
    ((VERBOSE)) && {
      local -- link
      for link in "${SKIPPED_LINKS[@]}"; do
        echo "  $link"
      done
    }
  }

  # Always show errors regardless of verbosity
  (( ${#ERROR_LINKS[@]} )) && {
    echo "Errors: ${#ERROR_LINKS[@]}"
    local -- link
    for link in "${ERROR_LINKS[@]}"; do
      echo "  $link"
    done
  }

  return 0
}

# --------------------------------------------------------------------------------
# Main function - handles argument parsing and orchestrates program flow
# --------------------------------------------------------------------------------
main() {
  local -a targets=() # array of script paths to symlink
  local -- target_dir='' scriptpath scriptprg target='' yn
  local -i exit_code=0

  # Show usage if no arguments provided
  (($#)) || >&2 usage 1

  # Parse command line options
  while (($#)); do case "$1" in
    # Feature options
    -t|--target-dir)    shift; target_dir="${1:-}" ;;
    -l|--list)          LISTIT=1 ;;
    -P|--no-prompt)     PROMPT=0 ;;
    -S|--scan-symlink)  SCANSYMLINK=1 ;;
    -d|--delete-broken-symlinks)
                        DELETE_DEAD_SYMLINKS=1 ;;
    # Basic options
    -h|--help)          usage 0 ;;
    -v|--verbose)       VERBOSE=1 ;;
    -q|--quiet)         VERBOSE=0 ;;
    -V|--version)       echo "$SCRIPT_NAME $VERSION"; exit 0 ;;
    -n|--dry-run)       DRY_RUN=1 ;;
    -D|--debug)         DEBUG=1 ;;
     # Handle combined short options (e.g., -vPd)
     -[tlPSdhvqVnD]*)   #shellcheck disable=SC2046
                        set -- '' $(printf -- "-%c " $(grep -o . <<<"${1:1}")) "${@:2}"
                        ;;
    # Error handling
    -*)                 die 22 "Invalid option ${1@Q}" ;;
    # Collect non-option arguments as target files/paths
    *)                  targets+=("$1") ;;
  esac; shift; done

  [[ -z $target_dir ]] && target_dir="$DEFAULT_TARGET_DIR"

  # Only check target dir if not in dry-run mode
  if ((DRY_RUN == 0)); then
    # Check if target directory exists and is writable
    [[ ! -d "$target_dir" ]] && die 3 "Target directory does not exist ${target_dir@Q}"

    [[ ! -w "$target_dir" ]] && die 2 "No write permission on target directory ${target_dir@Q}"
  fi

  # Process .symlink files if -l or -S options were used
  if ((LISTIT + SCANSYMLINK)); then
    # Allow only one startpath for listing or scanning operations
    ((${#targets[@]} > 1)) && die 1 "Can only specify one startpath for $( ((LISTIT)) && echo "listing" || echo "scanning" )."

    local -- startpath="$ORIG_DIR" symlink

    # Use the provided path if available, otherwise use current directory
    if ((${#targets[@]})); then
      # Handle relative paths correctly
      if [[ "${targets[0]}" != /* ]]; then
        startpath="$ORIG_DIR/${targets[0]}"
      else
        startpath="${targets[0]}"
      fi
      targets=()
    fi

    # Validate the startpath - use more robust path resolution
    info "Resolving path ${startpath@Q}"

    # Add timeout to readlink command to prevent hanging
    startpath=$(
        realpath -- "$startpath" 2>/dev/null || echo ''
      )

    [[ -n $startpath ]] || die 1 "Failed to resolve path ${startpath@Q} (timeout or error)"

    [[ -z "$startpath" ]] && die 1 "Failed to resolve path: empty result"

    info "Resolved path ${startpath@Q}"
    [[ -d "$startpath" ]] || die 3 "Path is not a directory ${startpath@Q}"

    # Ensure the path exists and is accessible
    [[ -x "$startpath" ]] || die 2 "Path exists but is not accessible ${startpath@Q}"

    # Handle the -l (list) option - just show contents of .symlink files
    if ((LISTIT)); then
      info "Listing contents of all .symlink files"
      info "  starting in ${startpath@Q}"

      local -a symlink_files=()
      local -- symlink
      debug "Finding .symlink files"

      # First check if the startpath is actually /usr/local/bin or contains it
      if [[ "$startpath" == "$DEFAULT_TARGET_DIR" || "$startpath" == "$DEFAULT_TARGET_DIR"/* ]]; then
        # We're scanning in or below the target directory, which is dangerous
        warn "Listing in target directory ($DEFAULT_TARGET_DIR) is not recommended"
        # To be extra safe, we just find the direct .symlink file
        if [[ -f "$startpath/.symlink" ]]; then
          symlink_files=("$startpath/.symlink")
        else
          warn "No .symlink files found in ${startpath@Q}"
          exit 50
        fi
      else
        # For standard directories, do a limited depth search
          if ! mapfile -t symlink_files < <(
              find "$startpath" -maxdepth "$FIND_MAX_DEPTH" \
                  -type f -name '.symlink' 2>/dev/null \
                | sort -u
              ); then
          die 1 "Error finding .symlink files for listing"
        fi

        (( ${#symlink_files[@]})) \
            || die 50 "No .symlink files found in ${startpath@Q}"
      fi

      debug "Found ${#symlink_files[@]} .symlink files for listing"

      for symlink in "${symlink_files[@]}"; do
        local -- symlink_dir
        symlink_dir=$(dirname -- "$symlink")
        echo "$(basename -- "$symlink_dir")/.symlink (${symlink_dir}):"
        grep -v '^$\|^#' "$symlink" | sed 's/^/    /'
        echo
      done
      exit 0
    fi

    # Handle the -S (scan) option - process .symlink files
    info "Scanning for all .symlink files starting in ${startpath@Q}"
    local -a symlinks=()
    local -- symlink

    # Safety first: Use controlled approach to avoid recursion issues
    startpath="${startpath%/}"  # Remove trailing slash if present
    debug "Start path for symlink scan ${startpath@Q}"

    if [[ ! -d "$startpath" ]] || [[ ! -r "$startpath" ]]; then
      die 3 "Cannot access directory ${startpath@Q}"
    fi

    # First check if the startpath is actually /usr/local/bin or contains it
    if [[ "$startpath" == "$DEFAULT_TARGET_DIR" || "$startpath" == "$DEFAULT_TARGET_DIR"/* ]]; then
      # We're scanning in or below the target directory, which is dangerous
      warn "Scanning in target directory ($DEFAULT_TARGET_DIR) is not recommended"
      # To be extra safe, we just find the direct .symlink file
      [[ -f "$startpath/.symlink" ]] || die 50 "No .symlink files found in ${startpath@Q}"
      symlinks=("$startpath/.symlink")
    else
      # For standard directories, do a limited depth search
      mapfile -t symlinks < <(
          find "$startpath" -maxdepth "$FIND_MAX_DEPTH" \
              -type f -name '.symlink' 2>/dev/null \
            | sort -u
          ) \
        ||  die 1 "Error finding .symlink files"

      (( ${#symlinks[@]} )) || die 50 "No .symlink files found in ${startpath@Q}"
    fi

    debug "Found ${#symlinks[@]} .symlink files to process"

    info "Found ${#symlinks[@]} .symlink files"

    # Process each .symlink file in batches
    if (( ${#symlinks[@]} == 0 )); then
      die 50 "No .symlink files to process"
    fi

    local -i batch_size=5
    local -i processed=0
    local -i total=${#symlinks[@]}
    local -i batch_count=$(( (total + batch_size - 1) / batch_size ))

    info "Found and will process ${#symlinks[@]} .symlink files"
    debug "Processing in $batch_count batches"

    # Process in batches
    for ((batch=0; batch<batch_count; batch+=1)); do
      local -i start=$((batch * batch_size))
      local -i end=$(( (batch + 1) * batch_size ))
      (( end > total )) && end=$total

      info "Processing batch $((batch+1))/$batch_count"
      debug "Processing files $((start+1))-$end of $total"

      # Process each file in this batch
      for ((i=start; i<end; i+=1)); do
        local -- symlink="${symlinks[$i]}"
        info "Processing: $symlink ($((i+1))/$total)"

        # Get the directory containing the .symlink file
        local -- symlink_dir
        symlink_dir=$(dirname -- "$symlink")
        local -i count=0

        # Read the .symlink file
        while IFS= read -r line || [[ -n "$line" ]]; do
          # Skip empty lines and comments
          [[ -z "$line" || "${line:0:1}" == "#" ]] && continue

          # Trim leading/trailing whitespace using our trim function
          line=$(trim "$line")
          [[ -z "$line" ]] && continue

          # Parse line for source_file and optional custom_name
          local -- source_file custom_name
          read -r source_file custom_name <<< "$line"

          # Get the full path to the script
          local -- script_path="$symlink_dir/$source_file"
          local -- link_name="${custom_name:-$(basename "$source_file")}"
          ((count+=1))

          if ((DRY_RUN)); then
            # For dry run, just check if it exists
            if [[ ! -f "$script_path" ]]; then
              error "Source file does not exist: '$script_path'"
              ERROR_LINKS+=("$script_path → $target_dir/$link_name (not found)")
              continue
            fi

            if [[ ! -x "$script_path" ]]; then
              error "Source file not executable: '$script_path'"
              ERROR_LINKS+=("$script_path → $target_dir/$link_name (not executable)")
              continue
            fi

            info "[DRY RUN] Would create symlink: $script_path → $target_dir/$link_name"
            CREATED_LINKS+=("$script_path → $target_dir/$link_name")
          else
            # For real operation, create the link
            if [[ ! -f "$script_path" ]]; then
              error "Source file does not exist: '$script_path'"
              ERROR_LINKS+=("$script_path → $target_dir/$link_name (not found)")
              continue
            fi

            if [[ ! -x "$script_path" ]]; then
              error "Source file not executable: '$script_path'"
              ERROR_LINKS+=("$script_path → $target_dir/$link_name (not executable)")
              continue
            fi

            if ln -sf "$(readlink -f "$script_path")" "$target_dir/$link_name"; then
              info "Created symlink: $script_path → $target_dir/$link_name"
              change_symlink_owner_perms "$script_path" "$target_dir/$link_name"
              CREATED_LINKS+=("$script_path → $target_dir/$link_name")
            else
              error "Failed to create symlink: $script_path → $target_dir/$link_name"
              ERROR_LINKS+=("$script_path → $target_dir/$link_name (link failed)")
            fi
          fi
        done < "$symlink"

        debug "Processed $count entries from $symlink"
        ((processed+=1))
      done

      debug "Completed batch $((batch+1))/$batch_count"
    done

    info "Processed all $processed .symlink files"

  else
    # Process individual target files
    (( ${#targets[@]} )) || die 1 "No target files specified. Use $SCRIPT_NAME --help for usage information."

    info "Processing ${#targets[@]} individual target files"

    # Process each target file
    local -i processed=0
    for target in "${targets[@]}"; do
      [[ -n "$target" ]] || { warn "Empty target specified. Skipping."; continue; }
      info "Processing: $target ($((processed+1))/${#targets[@]})"
      create_symlink "$target" "$target_dir" || true
      ((processed+=1))
    done
  fi

  # Optionally clean up broken symlinks
  ((DELETE_DEAD_SYMLINKS)) && delete_broken_symlinks "$target_dir"

  # Print summary of operations
  print_summary

  # Return appropriate exit code
  if (( ${#ERROR_LINKS[@]} )); then
    exit_code=1
    warn "There were errors during processing. Please check the error log."
  elif (( ${#CREATED_LINKS[@]} == 0 && ${#REPLACED_LINKS[@]} == 0 )); then
    if (( ${#SKIPPED_LINKS[@]} )); then
      warn "No symlinks created. All operations were skipped."
    else
      warn "No symlinks processed. Make sure your paths are correct."
    fi
  else
    success "Operation completed successfully."
  fi

  # Cleanup and finalization
  cd "$ORIG_DIR" 2>/dev/null || true
  printf '\e[?25h'

  # Add debug log
  if ((DEBUG)); then
    {
      echo "TRACE: Created links: ${#CREATED_LINKS[@]}"
      echo "TRACE: Replaced links: ${#REPLACED_LINKS[@]}"
      echo "TRACE: Skipped links: ${#SKIPPED_LINKS[@]}"
      echo "TRACE: Error links: ${#ERROR_LINKS[@]}"
      echo "TRACE: Script finishing with exit code: $exit_code"
      echo "TRACE: Execution completed at $(date)"
      echo "TRACE: =============== END OF EXECUTION ==============="
    } >> "$TRACEFILE"

    debug "Debug log written to $TRACEFILE"
  fi

  ((DRY_RUN)) && echo "Dry run completed. No changes were made."
  debug "Exiting with code: $exit_code"
  exit $exit_code
}


main "$@"
#fin
