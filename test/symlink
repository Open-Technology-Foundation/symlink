#!/bin/bash
#shellcheck disable=SC2034,SC1091,SC2155
# symlink - Tool to create symlinks in /usr/local/bin for executable files
# Simplifies making scripts and tools available in system PATH
set -euo pipefail

readonly VERSION='1.2.0'
readonly PRG0=$(readlink -f -- "$0" 2>/dev/null || readlink -en -- "$0")
readonly PRG=$(basename "$PRG0")
readonly PRGDIR=$(dirname "$PRG0")
readonly ORIG_DIR=$(pwd)
readonly DEFAULT_TARGET_DIR="/usr/local/bin"
readonly CRITICAL_FILES=("bash" "sh" "ls" "cp" "mv" "rm" "sudo" "chmod")

# Save original arguments to preserve them across sudo
readonly ORIG_ARGS=("$@")

# Message functions - defined early for use in need_sudo
error() { printf '\e[31m%s: %s\e[0m\n' "$PRG" "$*" >&2; }
warn() { printf '\e[33m%s: %s\e[0m\n' "$PRG" "$*" >&2; }
info() { ((VERBOSE)) && printf '%s: %s\n' "$PRG" "$*" >&2; }
success() { printf '\e[32m%s: %s\e[0m\n' "$PRG" "$*" >&2; }
debug() { [[ ${DEBUG:-0} -eq 1 ]] && printf '\e[36m%s DEBUG: %s\e[0m\n' "$PRG" "$*" >&2; }

# Initialize DRY_RUN early for sudo check
declare -i DRY_RUN=0
for arg in "$@"; do
  if [[ "$arg" == "-n" || "$arg" == "--dry-run" ]]; then
    DRY_RUN=1
    break
  fi
done

# Initialize VERBOSE early for message functions
declare -i VERBOSE=1
for arg in "$@"; do
  if [[ "$arg" == "-q" || "$arg" == "--quiet" ]]; then
    VERBOSE=0
    break
  fi
done

# Check for root privileges and elevate if needed
need_sudo() {
  if [[ "$(whoami)" != 'root' && $EUID != 0 ]]; then
    if [[ "$DRY_RUN" -eq 1 ]]; then 
      # Allow dry run without sudo
      warn "Running in dry-run mode without root privileges. Some checks will be skipped."
      return 1
    else
      return 0
    fi
  fi
  return 1
}

# Check if we need sudo
if need_sudo; then
  echo "This script requires root privileges. Running with sudo..."
  
  # Record all args to ensure they're passed through sudo correctly
  declare -a sudo_args=()
  for arg in "$@"; do
    # Quote the arguments to preserve spaces
    sudo_args+=("\"$arg\"")
  done
  
  # If debugging is needed, uncomment this
  # echo "sudo ${PRG0@Q} ${sudo_args[*]}"
  
  # Use eval to ensure proper argument handling
  eval "sudo \"$PRG0\" ${sudo_args[*]}"
  exit $?
fi

# Initialize remaining variables
# VERBOSE and DRY_RUN are already initialized early
declare -a CREATED_LINKS=()
declare -a REPLACED_LINKS=()
declare -a SKIPPED_LINKS=()
declare -a ERROR_LINKS=()

# Function to ensure cursor is visible and return to original directory
xcleanup() { 
  local -i exitcode=${1:-0}
  cd "$ORIG_DIR" 2>/dev/null || true
  printf '\e[?25h' # Restore cursor visibility
  
  # Only show dry run message at the very end
  if [[ $DRY_RUN -eq 1 && "${CLEANUP_EXECUTED:-0}" -eq 0 ]]; then
    CLEANUP_EXECUTED=1
    info "Dry run completed. No changes were made."
  fi
  exit $exitcode
}

# Set up trap for clean exit
trap 'xcleanup $?' SIGINT SIGTERM EXIT

# Set DEBUG=1 in the environment to see debug messages
[[ -n "${DEBUG:-}" ]] && debug "Starting in directory: $ORIG_DIR with args: ${ORIG_ARGS[*]}"

# Remove leading/trailing whitespace
trim() { 
  local v="$*"
  v="${v#"${v%%[![:blank:]]*}"}"
  echo -n "${v%"${v##*[![:blank:]]}"}"
}

# Global flag for error state
declare -i ERROR_STATE=0

# Exit with error code and message
die() { 
  local -i exitcode=1
  if (($#)); then 
    exitcode=$1
    shift 
  fi
  if (($#)); then 
    error "$@"
  fi
  
  # In file processing contexts, return instead of exit to continue with other files
  if [[ "${PROCESSING_FILES:-0}" -eq 1 ]]; then
    ERROR_STATE=$exitcode
    return $exitcode
  else
    exit $exitcode
  fi
}

# Check if a file is a critical system file
is_critical_file() {
  local filename="$1"
  for critical in "${CRITICAL_FILES[@]}"; do
    [[ "$filename" == "$critical" ]] && return 0
  done
  return 1
}

# Detect if we're in a terminal that supports colors
if [[ -t 1 ]]; then
  readonly COLOR_SUPPORT=1
else
  readonly COLOR_SUPPORT=0
fi

# Display usage information
usage() { cat <<EOT
$PRG $VERSION - Create symlinks for executable files to /usr/local/bin

Requires root privileges (automatically uses sudo if needed).

Description:
  This tool creates symbolic links in /usr/local/bin for executable files,
  making them available in the system PATH. It can directly link individual
  files or scan for .symlink configuration files.

Usage: 
  $PRG [-P] [-d] [-v|-q] [-n] scriptpath [scriptpath...]
    Link specific executable files to /usr/local/bin.

  $PRG -S [-P] [-d] [-v|-q] [-n] [startpath]
    Scan for .symlink files and create links for files listed in them.
    If startpath is omitted, the current directory is used.

  $PRG -l [startpath]
    List contents of all .symlink files found in startpath.

Format of .symlink files:
  Plain text files containing one executable filename per line.
  Empty lines and lines starting with # are ignored.
  Each file must be relative to the .symlink file's directory.

Options:
  -P, --no-prompt        Do not prompt to remove existing symlinks 
                         or files in /usr/local/bin.
  -S, --scan-symlink     Scan for .symlink files and process them.
  -d, --delete-broken-symlinks
                         Clean up broken symlinks in /usr/local/bin
                         after creating new links.
  -l, --list             List contents of all .symlink files.
  -n, --dry-run          Show what would happen without making changes.
  -v, --verbose          Show detailed output (default).
  -q, --quiet            Suppress informational messages.
  -V, --version          Display version information.
  -h, --help             Show this help message.

Exit codes:
  0: Success
  1: General error
  2: Permission denied
  3: File not found
  22: Invalid option
  50: No symlink files found

EOT
  exit 0
}

# Create a symbolic link
create_symlink() {
  debug "create_symlink called with: source_path='$1', target_dir='$2'"
  local source_path="$1"
  local target_dir="$2"
  local target_name
  local target_path
  local yn
  
  # Get target filename
  target_name=$(basename "$source_path")
  target_path="${target_dir}/${target_name}"
  
  # Check if the source file exists and is executable
  if [[ ! -f "$source_path" ]]; then
    error "Source file does not exist: '$source_path'"
    ERROR_LINKS+=("$source_path → $target_path (source not found)")
    # Don't exit during dry run mode, just return error code
    if [[ $DRY_RUN -eq 1 ]]; then
      info "[DRY RUN] Would fail: Source file not found: '$source_path'"
      return 0
    fi
    return 3
  fi
  
  if [[ ! -x "$source_path" ]]; then
    error "Source file is not executable: '$source_path'"
    ERROR_LINKS+=("$source_path → $target_path (not executable)")
    # Don't exit during dry run mode, just return error code
    if [[ $DRY_RUN -eq 1 ]]; then
      info "[DRY RUN] Would fail: Source file not executable: '$source_path'"
      return 0
    fi
    return 1
  fi
  
  # Get absolute path to source
  local source_abs_path
  source_abs_path=$(readlink -f -- "$source_path" 2>/dev/null || readlink -en -- "$source_path")
  
  # Check if target directory exists and is writable
  if [[ ! -d "$target_dir" ]]; then
    error "Target directory does not exist: '$target_dir'"
    ERROR_LINKS+=("$source_path → $target_path (target dir not found)")
    # Don't exit during dry run mode
    if [[ $DRY_RUN -eq 1 ]]; then
      info "[DRY RUN] Would fail: Target directory does not exist: '$target_dir'"
      return 0
    fi
    return 3
  fi
  
  if [[ ! -w "$target_dir" ]]; then
    error "No write permission on target directory: '$target_dir'"
    ERROR_LINKS+=("$source_path → $target_path (permission denied)")
    # Don't exit during dry run mode
    if [[ $DRY_RUN -eq 1 ]]; then
      info "[DRY RUN] Would fail: No write permission on target directory: '$target_dir'"
      return 0
    fi
    return 2
  fi
  
  # Check for critical system files
  if is_critical_file "$target_name"; then
    warn "WARNING: '$target_name' appears to be a critical system file!"
    if [[ $prompt -eq 1 ]]; then
      read -r -p "Are you ABSOLUTELY SURE you want to replace it? (yes/N) " yn
      [[ "${yn,,}" == "yes" ]] || {
        info "Skipping '$target_name'"
        SKIPPED_LINKS+=("$source_path → $target_path (critical file)")
        return 0
      }
    else
      warn "CRITICAL FILE REPLACED: '$target_name' (no-prompt mode)"
    fi
  fi
  
  # Dry run mode
  if [[ $DRY_RUN -eq 1 ]]; then
    if [[ -L "$target_path" ]]; then
      info "[DRY RUN] Would replace symlink: '$target_path'"
    elif [[ -e "$target_path" ]]; then
      info "[DRY RUN] Would replace file: '$target_path'"
    else
      info "[DRY RUN] Would create symlink: '$source_abs_path' → '$target_path'"
    fi
    return 0
  fi
  
  # Handle existing symlink
  if [[ -L "$target_path" ]]; then
    info "Symlink exists: '$target_path'"
    
    # Check if it's already pointing to our target
    local current_target
    current_target=$(readlink -f -- "$target_path" 2>/dev/null || readlink -en -- "$target_path")
    if [[ "$current_target" == "$source_abs_path" ]]; then
      info "Symlink already points to '$source_abs_path', skipping"
      SKIPPED_LINKS+=("$source_path → $target_path (already exists)")
      return 0
    fi
    
    if [[ $prompt -eq 1 ]]; then
      read -r -p "Remove existing symlink? (y/N) " yn
      [[ "${yn,,}" == "y" ]] || {
        info "Skipping '$target_name'"
        SKIPPED_LINKS+=("$source_path → $target_path (user skipped)")
        return 0
      }
    else
      info "Removing existing symlink: '$target_path'"
    fi
    rm "$target_path" || {
      error "Failed to remove existing symlink: '$target_path'"
      ERROR_LINKS+=("$source_path → $target_path (remove failed)")
      return 1
    }
    REPLACED_LINKS+=("$source_path → $target_path (replaced symlink)")
  fi
  
  # Handle existing regular file
  if [[ -e "$target_path" ]]; then
    info "File exists: '$target_path'"
    if [[ $prompt -eq 1 ]]; then
      read -r -p "Remove existing file? (y/N) " yn
      [[ "${yn,,}" == "y" ]] || {
        info "Skipping '$target_name'"
        SKIPPED_LINKS+=("$source_path → $target_path (user skipped)")
        return 0
      }
    else
      info "Removing existing file: '$target_path'"
    fi
    rm "$target_path" || {
      error "Failed to remove existing file: '$target_path'"
      ERROR_LINKS+=("$source_path → $target_path (remove failed)")
      return 1
    }
    REPLACED_LINKS+=("$source_path → $target_path (replaced file)")
  fi
  
  # Create the symbolic link
  info "Creating symlink: '$source_abs_path' → '$target_path'"
  ln -s "$source_abs_path" "$target_path" || {
    error "Failed to create symlink: '$target_path'"
    ERROR_LINKS+=("$source_path → $target_path (link failed)")
    return 1
  }
  
  CREATED_LINKS+=("$source_path → $target_path")
  success "Created symlink: '$target_name'"
  
  # Show details of the created symlink if verbose
  ((VERBOSE)) && ls -lsd "$target_path" 2>/dev/null
  
  return 0
}

# Process a .symlink file and create links for files listed in it
process_symlink_file() {
  debug "process_symlink_file called with: symlink_file='$1', target_dir='$2'"
  local symlink_file="$1"
  local target_dir="$2"
  local symlink_dir
  local script
  local count=0
  local -i errors=0
  
  # Set processing files mode to prevent early script termination
  PROCESSING_FILES=1
  
  # Get the directory containing the .symlink file
  symlink_dir=$(dirname -- "$symlink_file")
  
  debug "Processing .symlink file: '$symlink_file'"
  debug "Base directory: '$symlink_dir'"
  
  # Read each line from the .symlink file
  while IFS= read -r line; do
    # Trim whitespace and skip empty or comment lines
    script=$(trim "$line")
    [[ -z $script || ${script:0:1} == '#' ]] && continue
    
    # Construct the full path to the script (relative to .symlink file)
    local script_path="${symlink_dir}/${script}"
    
    # Create symlink for this script
    create_symlink "$script_path" "$target_dir"
    ((count++))
  done < "$symlink_file"
  
  debug "Processed $count entries from '$symlink_file'"
  
  # Reset processing files mode
  PROCESSING_FILES=0
  
  if [[ $ERROR_STATE -ne 0 ]]; then
    warn "Encountered errors while processing '$symlink_file', continuing with next file"
    ERROR_STATE=0  # Reset error state
  fi
  
  return 0
}

# Find and delete broken symlinks in the target directory
delete_broken_symlinks() {
  local target_dir="$1"
  local count=0
  local broken_links
  
  info "Finding broken symlinks in '$target_dir'"
  
  if [[ $DRY_RUN -eq 1 ]]; then
    mapfile -t broken_links < <(find "$target_dir" -xtype l)
    for link in "${broken_links[@]}"; do
      info "[DRY RUN] Would delete broken symlink: '$link'"
      ((count++))
    done
    [[ $count -gt 0 ]] && info "[DRY RUN] Would delete $count broken symlinks"
    return 0
  fi
  
  # Actually delete broken symlinks
  mapfile -t broken_links < <(find "$target_dir" -xtype l)
  for link in "${broken_links[@]}"; do
    info "Deleting broken symlink: '$link'"
    rm "$link" && ((count++))
  done
  
  [[ $count -gt 0 ]] && success "Deleted $count broken symlinks"
  return 0
}

# Print summary of operations
print_summary() {
  # Skip summary for dry run mode
  [[ $DRY_RUN -eq 1 ]] && return 0
  
  # Skip empty summary if nothing happened and we're not verbose
  if [[ ${#CREATED_LINKS[@]} -eq 0 && ${#REPLACED_LINKS[@]} -eq 0 && 
        ${#SKIPPED_LINKS[@]} -eq 0 && ${#ERROR_LINKS[@]} -eq 0 ]]; then
    if ((VERBOSE)); then
      echo -e "\n======== SUMMARY ========"
      echo "No operations performed."
      echo -e "==========================\n"
    fi
    return 0
  fi
  
  # Calculate total processed
  local -i total=$((${#CREATED_LINKS[@]} + ${#REPLACED_LINKS[@]} + ${#SKIPPED_LINKS[@]} + ${#ERROR_LINKS[@]}))
  
  echo -e "\n======== SUMMARY ========"
  echo "Total processed: $total"
  
  [[ ${#CREATED_LINKS[@]} -gt 0 ]] && {
    echo -e "\nCreated symlinks: ${#CREATED_LINKS[@]}"
    # Always show details in verbose mode, otherwise just show count
    if ((VERBOSE)); then
      for link in "${CREATED_LINKS[@]}"; do
        echo "  $link"
      done
    fi
  }
  
  [[ ${#REPLACED_LINKS[@]} -gt 0 ]] && {
    echo -e "\nReplaced symlinks: ${#REPLACED_LINKS[@]}"
    if ((VERBOSE)); then
      for link in "${REPLACED_LINKS[@]}"; do
        echo "  $link"
      done
    fi
  }
  
  [[ ${#SKIPPED_LINKS[@]} -gt 0 ]] && {
    echo -e "\nSkipped symlinks: ${#SKIPPED_LINKS[@]}"
    if ((VERBOSE)); then
      for link in "${SKIPPED_LINKS[@]}"; do
        echo "  $link"
      done
    fi
  }
  
  # Always show errors regardless of verbosity
  [[ ${#ERROR_LINKS[@]} -gt 0 ]] && {
    echo -e "\nErrors: ${#ERROR_LINKS[@]}"
    for link in "${ERROR_LINKS[@]}"; do
      echo "  $link"
    done
  }
  
  echo -e "\n=========================="
}

# Main function - processes command line options and executes requested operations
main() {
  local -a targets=()          # Array of script paths to symlink
  local target_dir="$DEFAULT_TARGET_DIR"
  local scriptpath scriptprg target='' yn
  local -i prompt=1 scansymlink=0 delete_dead_symlinks=0 listit=0
  local -i exit_code=0
  
  # Show usage if no arguments provided
  (($#)) || usage
  
  # Parse command line options
  while (($#)); do case "$1" in
    # Basic options
    -h|--help) usage;; 
    -v|--verbose) VERBOSE=1;; 
    -q|--quiet) VERBOSE=0;; 
    -V|--version) echo "$PRG $VERSION"; exit 0;;
    -n|--dry-run) DRY_RUN=1;;
    # Feature options
    -l|--list)          listit=1;;
    -P|--no-prompt)     prompt=0 ;;
    -S|--scan-symlink)  scansymlink=1 ;;
    -d|--delete-broken-symlinks) 
                        delete_dead_symlinks=1 ;;
    # Handle combined short options (e.g., -vPd)
    -[hvqVPSdn]*)       #shellcheck disable=SC2046 # expand aggregated short options
                        set -- '' $(printf -- "-%c " $(grep -o . <<<"${1:1}")) "${@:2}" ;;
    # Error handling
    -*)                 die 22 "Invalid option '$1'" ;;
    # Collect non-option arguments as target files/paths
    *)                  targets+=("$1") ;;
  esac; shift; done
  
  # Early check if target directory exists and is writable
  if [[ ! -d "$target_dir" ]]; then
    die 3 "Target directory does not exist: '$target_dir'"
  fi
  
  if [[ ! -w "$target_dir" && $DRY_RUN -eq 0 ]]; then
    die 2 "No write permission on target directory: '$target_dir'"
  fi
  
  # Process .symlink files if -l or -S options were used
  if ((listit + scansymlink)); then
    # Allow only one startpath for listing or scanning operations
    ((${#targets[@]} > 1)) && die 1 "Can only specify one startpath for $( ((listit)) && echo "listing" || echo "scanning" )."
    local startpath="$ORIG_DIR"
    local symlink
    # Use the provided path if available, otherwise use current directory
    if ((${#targets[@]})); then
      # Handle relative paths correctly
      if [[ "${targets[0]}" != /* ]]; then
        startpath="$ORIG_DIR/${targets[0]}"
      else
        startpath="${targets[0]}"
      fi
      targets=()
    fi
    
    # Validate the startpath
    info "Resolving path: '$startpath'"
    startpath=$(readlink -f -- "$startpath" 2>/dev/null || readlink -en -- "$startpath" 2>/dev/null)
    if [[ -z "$startpath" ]]; then
      error "Failed to resolve path '$startpath'"
      die 1 "Invalid startpath. Make sure the path exists."
    fi
    
    info "Resolved path: '$startpath'"
    if [[ ! -d "$startpath" ]]; then
      error "Path is not a directory: '$startpath'"
      die 3 "'$startpath' must be a directory."
    fi
    
    # Handle the -l (list) option - just show contents of .symlink files
    if ((listit)); then
      info "Listing contents of all .symlink files"
      info "  starting in '$startpath'"
      
      local symlink_files=()
      mapfile -t symlink_files < <(find "$startpath" -type f -name .symlink)
      
      if [[ ${#symlink_files[@]} -eq 0 ]]; then
        warn "No .symlink files found in '$startpath'"
        exit 50
      fi
      
      for symlink in "${symlink_files[@]}"; do
        local symlink_dir=$(dirname -- "$symlink")
        echo "$(basename -- "$symlink_dir")/.symlink (${symlink_dir}):"
        grep -v '^$\|^#' "$symlink" | sed 's/^/    /'
        echo
      done
      exit 0
    fi
    
    # Handle the -S (scan) option - process .symlink files
    info "Scanning for all .symlink files starting in '$startpath'"
    local -a symlinks=()
    
    # Find all .symlink files
    mapfile -t symlinks < <(find "$startpath"/ -type f -name '.symlink')
    
    if [[ ${#symlinks[@]} -eq 0 ]]; then
      warn "No .symlink files found in '$startpath'"
      exit 50
    fi
    
    info "Found ${#symlinks[@]} .symlink files"
    
    # Process each .symlink file
    debug "About to process ${#symlinks[@]} .symlink files"
    PROCESSING_FILES=1
    local -i processed=0
    for symlink in "${symlinks[@]}"; do
      info "Processing: $symlink ($((processed+1))/${#symlinks[@]})"
      debug "Starting processing of symlink file #$((processed+1)): $symlink"
      process_symlink_file "$symlink" "$target_dir"
      debug "Finished processing symlink file #$((processed+1)): $symlink"
      ((processed++))
    done
    debug "Processed $processed .symlink files out of ${#symlinks[@]}"
    PROCESSING_FILES=0
  else
    # Process individual target files
    if [[ ${#targets[@]} -eq 0 ]]; then
      die 1 "No target files specified. Use $PRG --help for usage information."
    fi
    
    info "Processing ${#targets[@]} individual target files"
    info "From directory: '$ORIG_DIR'"
    
    # Set processing mode to continue on errors
    PROCESSING_FILES=1
    local -i processed=0
    
    for target in "${targets[@]}"; do
      [[ -n "$target" ]] || { error "Empty target specified. Skipping."; continue; }
      info "Processing: $target ($((processed+1))/${#targets[@]})"
      create_symlink "$target" "$target_dir"
      ((processed++))
    done
    
    PROCESSING_FILES=0
  fi
  
  # Optionally clean up broken symlinks
  if ((delete_dead_symlinks)); then
    delete_broken_symlinks "$target_dir"
  fi
  
  # Print summary of operations
  print_summary
  
  # Return appropriate exit code
  if [[ ${#ERROR_LINKS[@]} -gt 0 ]]; then
    exit_code=1
    warn "There were errors during processing. Please check the error log."
  elif [[ ${#CREATED_LINKS[@]} -eq 0 && ${#REPLACED_LINKS[@]} -eq 0 ]]; then
    if [[ ${#SKIPPED_LINKS[@]} -gt 0 ]]; then
      warn "No symlinks created. All operations were skipped."
    else
      warn "No symlinks processed. Make sure your paths are correct."
    fi
  else
    success "Operation completed successfully."
  fi
  
  exit $exit_code
}

main "$@"
#fin